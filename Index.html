
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7x7 Averaging Filter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
            text-align: center;
        }
        .highlighted-input {
            outline: 2px solid #3b82f6;
            outline-offset: -2px;
            z-index: 10;
        }
        .highlighted-output {
            outline: 2px solid #3b82f6;
            outline-offset: -2px;
            z-index: 10;
        }
    </style>
</head>
<body class="p-4 md:p-8 flex items-center justify-center min-h-screen">

    <div class="bg-white rounded-2xl shadow-xl p-6 md:p-10 w-full max-w-5xl">

        <h1 class="text-3xl md:text-4xl font-bold text-center text-gray-800 mb-2">
            7x7 Image Filters
        </h1>
        <p class="text-center text-gray-500 mb-8">
            Click on any input cell to see its calculated average. Click "Calculate All" to get all results at once.
        </p>

        <!-- Control Panel -->
        <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mb-8">
            <div class="flex items-center gap-2">
                <label for="filter-select" class="font-medium text-gray-700">Select Filter:</label>
                <select id="filter-select" class="border border-gray-300 rounded-md p-2">
                    <option value="lowpass">Low-pass (Averaging)</option>
                    <option value="highpass">High-pass</option>
                    <option value="highboost">High-boost</option>
                    <option value="median">Median</option>
                    <option value="prewitt">Prewitt</option>
                    <option value="sobel">Sobel</option>
                </select>
            </div>
            <div class="flex items-center gap-2">
                <label for="kernel-size" class="font-medium text-gray-700">Kernel Size:</label>
                <select id="kernel-size" class="border border-gray-300 rounded-md p-2">
                    <option value="3">3x3</option>
                    <option value="5">5x5</option>
                    <option value="7">7x7</option>
                </select>
            </div>
            <div id="highboost-gain-container" class="flex items-center gap-2 hidden">
                <label for="highboost-gain" class="font-medium text-gray-700">Gain (A):</label>
                <input type="number" id="highboost-gain" value="5" min="1" class="w-20 text-center border border-gray-300 rounded-md p-2">
            </div>
        </div>
        
        <div class="flex flex-col md:flex-row justify-center items-start gap-8 md:gap-12">

            <!-- Input Grid -->
            <div class="w-full md:w-1/2">
                <h2 class="text-xl font-semibold mb-4 text-center">Input Grid</h2>
                <div id="input-grid" class="grid grid-cols-7 gap-1 md:gap-2 border-2 border-gray-300 rounded-lg p-2 md:p-4">
                    <!-- Grid cells will be generated by JS -->
                </div>
            </div>

            <!-- Output Grid -->
            <div class="w-full md:w-1/2">
                <h2 class="text-xl font-semibold mb-4 text-center">Output Grid</h2>
                <div id="output-grid" class="grid grid-cols-7 gap-1 md:gap-2 border-2 border-gray-300 rounded-lg p-2 md:p-4">
                    <!-- Grid cells will be generated by JS -->
                </div>
            </div>

        </div>

        <div class="flex justify-center mt-8">
            <button id="calculate-all-btn" class="px-8 py-3 bg-indigo-600 text-white font-semibold rounded-full shadow-lg hover:bg-indigo-700 transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                Calculate All
            </button>
        </div>

        <div id="message-box" class="mt-8 p-4 bg-gray-100 text-gray-800 border border-gray-300 rounded-xl text-center min-h-[5rem] flex items-center justify-center">
            Click on a cell in the input grid to see the detailed calculation here.
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gridSize = 7;
            const inputGrid = document.getElementById('input-grid');
            const outputGrid = document.getElementById('output-grid');
            const calculateAllBtn = document.getElementById('calculate-all-btn');
            const messageBox = document.getElementById('message-box');
            const filterSelect = document.getElementById('filter-select');
            const kernelSizeSelect = document.getElementById('kernel-size');
            const highboostGainContainer = document.getElementById('highboost-gain-container');
            const highboostGainInput = document.getElementById('highboost-gain');

            // --- Grid Generation ---
            function createGrids() {
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        // Create input cell
                        const inputCell = document.createElement('input');
                        inputCell.type = 'number';
                        inputCell.value = Math.floor(Math.random() * 4).toString(); // Random value from 0-3
                        inputCell.classList.add('w-full', 'h-10', 'text-center', 'border', 'border-gray-300', 'rounded-md', 'focus:outline-none', 'focus:border-indigo-500', 'transition-colors', 'duration-200');
                        inputCell.setAttribute('data-row', i);
                        inputCell.setAttribute('data-col', j);
                        inputGrid.appendChild(inputCell);

                        // Create output cell
                        const outputCell = document.createElement('div');
                        outputCell.classList.add('w-full', 'h-10', 'flex', 'items-center', 'justify-center', 'text-center', 'bg-gray-100', 'border', 'border-gray-300', 'rounded-md', 'font-medium', 'text-gray-700');
                        outputCell.setAttribute('data-row', i);
                        outputCell.setAttribute('data-col', j);
                        outputGrid.appendChild(outputCell);
                    }
                }
            }

            // --- Filter Definitions ---
            const filters = {
                'lowpass': { name: 'Low-pass (Averaging)', type: 'convolution', normalize: true },
                'highpass': { name: 'High-pass', type: 'convolution', normalize: false },
                'highboost': { name: 'High-boost', type: 'convolution', normalize: false },
                'median': { name: 'Median', type: 'median' },
                'prewitt': { name: 'Prewitt', type: 'prewitt' },
                'sobel': { name: 'Sobel', type: 'prewitt' }
            };
            
            // --- Dynamic Kernel Generation ---
            function getKernel(filterName, size) {
                const center = Math.floor(size / 2);
                let kernel = Array.from({ length: size }, () => Array(size).fill(0));
                
                if (filterName === 'lowpass') {
                    kernel = Array.from({ length: size }, () => Array(size).fill(1));
                } else if (filterName === 'highpass') {
                    const totalSum = size * size - 1;
                    kernel = Array.from({ length: size }, () => Array(size).fill(-1));
                    kernel[center][center] = totalSum;
                } else if (filterName === 'highboost') {
                    const A = parseFloat(highboostGainInput.value);
                    const highpassKernel = getKernel('highpass', size);
                    const identityKernel = Array.from({ length: size }, () => Array(size).fill(0));
                    identityKernel[center][center] = 1;
                    
                    for(let i = 0; i < size; i++) {
                        for(let j = 0; j < size; j++) {
                            kernel[i][j] = (highpassKernel[i][j] * (A - 1)) + identityKernel[i][j];
                        }
                    }
                }
                
                return kernel;
            }

            // A separate function for generating Prewitt/Sobel kernels
            function getEdgeKernels(filterName, size) {
                const halfKernel = Math.floor(size / 2);
                let kernelX = Array.from({ length: size }, () => Array(size).fill(0));
                let kernelY = Array.from({ length: size }, () => Array(size).fill(0));

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        // Prewitt x-kernel
                        if (j < halfKernel) kernelX[i][j] = -1;
                        if (j > halfKernel) kernelX[i][j] = 1;

                        // Prewitt y-kernel
                        if (i < halfKernel) kernelY[i][j] = -1;
                        if (i > halfKernel) kernelY[i][j] = 1;
                    }
                }

                if (filterName === 'sobel') {
                    // Adjust central column/row for Sobel
                    for (let i = 0; i < size; i++) {
                        kernelX[i][halfKernel - 1] *= 2;
                        kernelX[i][halfKernel + 1] *= 2;
                        kernelY[halfKernel - 1][i] *= 2;
                        kernelY[halfKernel + 1][i] *= 2;
                    }
                }

                return { kernelX, kernelY };
            }

            // --- Calculation Logic ---
            function getValuesFromInput() {
                const inputValues = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
                const inputElements = inputGrid.querySelectorAll('input');
                inputElements.forEach(input => {
                    const row = parseInt(input.getAttribute('data-row'));
                    const col = parseInt(input.getAttribute('data-col'));
                    inputValues[row][col] = parseFloat(input.value) || 0;
                });
                return inputValues;
            }

            function calculateSingle(row, col) {
                // Clear existing highlights
                document.querySelectorAll('.highlighted-input').forEach(el => el.classList.remove('highlighted-input'));
                document.querySelectorAll('.highlighted-output').forEach(el => el.classList.remove('highlighted-output'));

                const inputValues = getValuesFromInput();
                const selectedFilter = filterSelect.value;
                const kernelSize = parseInt(kernelSizeSelect.value);
                const filter = filters[selectedFilter];
                const halfKernel = Math.floor(kernelSize / 2);

                let result = 0;
                let calculationDetails = [];
                let highlightedInputCells = [];

                // Get neighborhood values and highlight cells
                const getNeighborhoodValues = () => {
                    const values = [];
                    for (let k = -halfKernel; k <= halfKernel; k++) {
                        for (let l = -halfKernel; l <= halfKernel; l++) {
                            const wrappedRow = (row + k + gridSize) % gridSize;
                            const wrappedCol = (col + l + gridSize) % gridSize;
                            const value = inputValues[wrappedRow][wrappedCol];
                            values.push(value);
                            highlightedInputCells.push(inputGrid.querySelector(`[data-row="${wrappedRow}"][data-col="${wrappedCol}"]`));
                        }
                    }
                    return values;
                };

                if (filter.type === 'convolution') {
                    let sum = 0;
                    const neighborhoodValues = getNeighborhoodValues();
                    const kernel = getKernel(selectedFilter, kernelSize);
                    
                    for (let i = 0; i < kernelSize * kernelSize; i++) {
                        const kernelRow = Math.floor(i / kernelSize);
                        const kernelCol = i % kernelSize;
                        const value = neighborhoodValues[i] * kernel[kernelRow][kernelCol];
                        sum += value;
                        calculationDetails.push(`(${neighborhoodValues[i]}*${kernel[kernelRow][kernelCol]})`);
                    }
                    result = sum;
                    if (filter.normalize) {
                        result /= (kernelSize * kernelSize);
                        messageBox.innerHTML = `Calculating for cell (${row}, ${col}):<br>${filter.name}: 1/${kernelSize*kernelSize} * (${calculationDetails.join(' + ')}) = ${sum}/${kernelSize*kernelSize} = ${result.toFixed(2)}`;
                    } else {
                        messageBox.innerHTML = `Calculating for cell (${row}, ${col}):<br>${filter.name}: (${calculationDetails.join(' + ')}) = ${sum} = ${result.toFixed(2)}`;
                    }

                } else if (filter.type === 'median') {
                    const neighborhoodValues = getNeighborhoodValues();
                    neighborhoodValues.sort((a, b) => a - b);
                    const medianIndex = Math.floor(neighborhoodValues.length / 2);
                    result = neighborhoodValues[medianIndex];
                    messageBox.innerHTML = `Calculating for cell (${row}, ${col}):<br>${filter.name}: The sorted neighborhood is [${neighborhoodValues.join(', ')}]. The median is ${result.toFixed(2)}.`;
                } else if (filter.type === 'prewitt') {
                    const neighborhoodValues = getNeighborhoodValues();
                    const { kernelX, kernelY } = getEdgeKernels(selectedFilter, kernelSize);
                    let sumX = 0;
                    let sumY = 0;

                    for (let i = 0; i < kernelSize * kernelSize; i++) {
                        const kernelRow = Math.floor(i / kernelSize);
                        const kernelCol = i % kernelSize;
                        sumX += neighborhoodValues[i] * kernelX[kernelRow][kernelCol];
                        sumY += neighborhoodValues[i] * kernelY[kernelRow][kernelCol];
                    }
                    result = Math.sqrt(Math.pow(sumX, 2) + Math.pow(sumY, 2));
                    messageBox.innerHTML = `Calculating for cell (${row}, ${col}):<br>${filter.name}: Gx=${sumX.toFixed(2)}, Gy=${sumY.toFixed(2)}. Result = sqrt(${sumX.toFixed(2)}² + ${sumY.toFixed(2)}²) = ${result.toFixed(2)}`;
                }
                
                // Highlight the selected input cells
                highlightedInputCells.forEach(cell => {
                    if (cell) cell.classList.add('highlighted-input');
                });

                // Update and highlight the single output cell
                const outputCell = outputGrid.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (outputCell) {
                    outputCell.textContent = result.toFixed(2);
                    outputCell.classList.add('highlighted-output');
                }
            }

            function calculateAll() {
                // Clear existing highlights
                document.querySelectorAll('.highlighted-input').forEach(el => el.classList.remove('highlighted-input'));
                document.querySelectorAll('.highlighted-output').forEach(el => el.classList.remove('highlighted-output'));
                
                messageBox.innerHTML = 'Calculating all values...';
                const inputValues = getValuesFromInput();
                const outputValues = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
                const selectedFilter = filterSelect.value;
                const kernelSize = parseInt(kernelSizeSelect.value);
                const filter = filters[selectedFilter];
                const halfKernel = Math.floor(kernelSize / 2);

                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        let result = 0;
                        const neighborhoodValues = [];
                        for (let k = -halfKernel; k <= halfKernel; k++) {
                            for (let l = -halfKernel; l <= halfKernel; l++) {
                                const wrappedRow = (i + k + gridSize) % gridSize;
                                const wrappedCol = (j + l + gridSize) % gridSize;
                                neighborhoodValues.push(inputValues[wrappedRow][wrappedCol]);
                            }
                        }

                        if (filter.type === 'convolution') {
                            let sum = 0;
                            const kernel = getKernel(selectedFilter, kernelSize);
                            for (let idx = 0; idx < kernelSize * kernelSize; idx++) {
                                const kernelRow = Math.floor(idx / kernelSize);
                                const kernelCol = idx % kernelSize;
                                sum += neighborhoodValues[idx] * kernel[kernelRow][kernelCol];
                            }
                            result = filter.normalize ? sum / (kernelSize * kernelSize) : sum;
                        } else if (filter.type === 'median') {
                            neighborhoodValues.sort((a, b) => a - b);
                            const medianIndex = Math.floor(neighborhoodValues.length / 2);
                            result = neighborhoodValues[medianIndex];
                        } else if (filter.type === 'prewitt') {
                            const { kernelX, kernelY } = getEdgeKernels(selectedFilter, kernelSize);

                            let sumX = 0;
                            let sumY = 0;
                            for (let idx = 0; idx < kernelSize * kernelSize; idx++) {
                                const kernelRow = Math.floor(idx / kernelSize);
                                const kernelCol = idx % kernelSize;
                                sumX += neighborhoodValues[idx] * kernelX[kernelRow][kernelCol];
                                sumY += neighborhoodValues[idx] * kernelY[kernelRow][kernelCol];
                            }
                            result = Math.sqrt(Math.pow(sumX, 2) + Math.pow(sumY, 2));
                        }

                        outputValues[i][j] = result;
                    }
                }

                const outputCells = outputGrid.querySelectorAll('div');
                outputCells.forEach(cell => {
                    const row = parseInt(cell.getAttribute('data-row'));
                    const col = parseInt(cell.getAttribute('data-col'));
                    cell.textContent = outputValues[row][col].toFixed(2);
                });

                messageBox.innerHTML = 'All cells have been calculated. Click an input cell for a detailed view.';
            }

            // --- Event Listeners ---
            inputGrid.addEventListener('click', (event) => {
                const target = event.target;
                if (target.tagName === 'INPUT') {
                    const row = parseInt(target.getAttribute('data-row'));
                    const col = parseInt(target.getAttribute('data-col'));
                    calculateSingle(row, col);
                }
            });

            calculateAllBtn.addEventListener('click', calculateAll);

            filterSelect.addEventListener('change', () => {
                if (filterSelect.value === 'highboost') {
                    highboostGainContainer.classList.remove('hidden');
                } else {
                    highboostGainContainer.classList.add('hidden');
                }
                const outputCells = outputGrid.querySelectorAll('div');
                outputCells.forEach(cell => cell.textContent = '');
                messageBox.innerHTML = 'Output has been reset. Select a cell or click "Calculate All".';
            });

            kernelSizeSelect.addEventListener('change', () => {
                // Clear output grid
                const outputCells = outputGrid.querySelectorAll('div');
                outputCells.forEach(cell => cell.textContent = '');
                messageBox.innerHTML = 'Output has been reset. Select a cell or click "Calculate All".';
            });

            highboostGainInput.addEventListener('input', () => {
                // Clear output grid
                const outputCells = outputGrid.querySelectorAll('div');
                outputCells.forEach(cell => cell.textContent = '');
                messageBox.innerHTML = 'Output has been reset. Select a cell or click "Calculate All".';
            });

            // Initial grid creation
            createGrids();
        });
    </script>
</body>
</html>